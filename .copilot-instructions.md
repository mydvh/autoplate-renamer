# Copilot Instructions for Autoplate Renamer Project

## Project Overview
**Autoplate Renamer** is a full-stack web application for automated license plate renaming using AI (Google Gemini API). The project uses TypeScript, Express.js (backend), React with Vite (frontend), PostgreSQL, and Docker.

## Tech Stack
- **Backend:** Node.js 20, Express.js, TypeORM, TypeScript
- **Frontend:** React 18, Vite, TypeScript, Tailwind CSS (possibly)
- **Database:** PostgreSQL 16
- **Deployment:** Docker & Docker Compose
- **API:** RESTful with JWT authentication

## Project Structure

### Backend (`/backend`)
```
src/
├── config/database.ts          # TypeORM configuration with synchronize enabled
├── entities/                   # Database entities
│   ├── User.ts                # User entity (Admin/User roles)
│   ├── ProcessingLog.ts        # Logging entity for plate renaming
│   └── SystemConfig.ts         # System configuration entity
├── middleware/auth.middleware.ts    # JWT authentication middleware
├── routes/                     # API route handlers
│   ├── auth.routes.ts
│   ├── analysis.routes.ts      # Gemini API integration
│   ├── log.routes.ts
│   ├── user.routes.ts
│   └── config.routes.ts
├── migrations/                 # TypeORM migrations
└── index.ts                    # Express server entry point
```

### Frontend (`/frontend`)
```
src/
├── components/                 # React components
│   ├── Login.tsx
│   ├── RenamerTool.tsx        # Main tool component
│   ├── AdminDashboard.tsx
│   └── FileRow.tsx
├── services/                   # API & service layer
│   ├── apiService.ts
│   ├── dbService.ts
│   └── geminiService.ts
├── utils/                      # Utility functions
│   ├── pythonTemplate.ts
│   └── renamingLogic.ts
├── App.tsx                     # Root component
└── index.tsx                   # Entry point
```

## Key Configuration Files

### `.env` Variables
```dotenv
DB_HOST=143.198.85.151
DB_PORT=5432
DB_USER=mydvh-usr
DB_PASSWORD=0vUS2H7bTboOxH
DB_NAME=auto-rename-plate-db
JWT_SECRET=MAJ35wIwdiy3zEAB2gJ9t1OZ73ACTr8fm7fMRXRhzZB
GEMINI_API_KEY=<Google Gemini API Key>
NODE_ENV=production
PORT=5000
FRONTEND_URL=http://localhost:3000
```

### Docker Setup
- **docker-compose.yml:** Orchestrates frontend (Nginx), backend (Node), and database
- **Backend Dockerfile:** Multi-stage build for production
- **Frontend Dockerfile:** Vite build + Nginx serving
- Services communicate via `autoplate-network` bridge network

## Critical Implementation Details

### Database
- **TypeORM Configuration:** `synchronize: true` (auto-creates tables from entities)
- **Entities:** User, ProcessingLog, SystemConfig
- **Circular Dependency Fix:** User entity uses string-based relationships: `@OneToMany('ProcessingLog', 'user')`
- **Authentication:** JWT tokens with 'ADMIN' and 'USER' roles

### API
- **Base URL:** `http://localhost:5000/api`
- **Authentication:** JWT Bearer tokens (Authorization header)
- **Key Endpoints:**
  - `POST /auth/login` - Login with email/password
  - `POST /auth/register` - User registration
  - `POST /analysis/analyze` - Image analysis (Gemini API)
  - `GET /logs` - Get processing history
  - `POST /logs` - Create new log entry
  - `GET /users/profile` - Get user profile
  - `GET /api/health` - Health check

### Frontend
- **Vite Dev Server:** Runs on port 3000 during development
- **Build Output:** Compiled to `/dist` for production
- **CORS:** Frontend URL must be configured in backend `.env`
- **API Integration:** Calls backend API for all operations

## Common Development Tasks

### Running the Project
```bash
# With Docker (recommended)
docker-compose up --build

# Local development
cd backend && npm run dev
cd frontend && npm run dev
```

### Database Operations
```bash
# View container logs
docker-compose logs -f autoplate-backend

# Access PostgreSQL
docker-compose exec autoplate-backend psql -U postgres -d auto-rename-plate-db
```

### Debugging
- Backend: Check `/dist` compiled output
- Frontend: Vite HMR for hot reload
- Database: `synchronize: true` auto-creates schema
- Migrations: Auto-run on server startup

## Known Issues & Solutions

### Issue: "Cannot access 'User' before initialization"
**Status:** ✅ FIXED
- **Cause:** Circular dependency between entities
- **Solution:** Use string-based relationships in User.ts: `@OneToMany('ProcessingLog', 'user')`

### Issue: Tables not created in database
**Status:** ✅ FIXED
- **Cause:** `synchronize: false` in production mode
- **Solution:** Changed to `synchronize: true`

### Issue: Admin user not created on startup
**Status:** ⚠️ NEEDS ATTENTION
- **Cause:** Migrations only run once; synchronize doesn't create seed data
- **Solution:** Need to implement seed function in `index.ts` after `AppDataSource.initialize()`

## Coding Guidelines

### TypeScript
- Use strict mode in `tsconfig.json`
- Type all function parameters and returns
- Use enums for constants (e.g., UserRole)

### Entity Relationships
- Always use lazy-loaded relationships: `() => Entity` or `'Entity'` (string)
- Avoid circular imports; use string-based references when needed

### API Routes
- All protected routes require JWT middleware
- Return consistent response format
- Validate input with middleware before handler

### Error Handling
- Log errors with clear messages
- Return appropriate HTTP status codes
- Include error details in response body

## File Naming Conventions
- **Routes:** `*.routes.ts`
- **Entities:** `*.ts` (PascalCase)
- **Services:** `*Service.ts`
- **Middleware:** `*.middleware.ts`
- **Migrations:** `TIMESTAMP-Description.ts`

## Important Notes for Contributors

1. **DO NOT** commit `.env` file - use `.env.example` as template
2. **DO** run `docker-compose down -v` to reset database if needed
3. **DO** use `npm run build` before creating Docker images
4. **DO** check `INSTRUCTIONS.md` for complete API documentation
5. **DO** ensure `.dockerignore` excludes unnecessary files
6. **DO** update migration files when adding new entities

## Performance Considerations

- Frontend build optimized via Vite
- Backend uses connection pooling for database
- Images analyzed via Google Gemini API (rate limit: 60 req/min on free tier)
- Consider adding caching for frequently analyzed plates

## Security Reminders

- Keep JWT_SECRET strong and unique per environment
- Validate all user inputs on backend
- Use HTTPS in production
- Sanitize database queries (TypeORM prevents SQL injection)
- Implement rate limiting for API endpoints
- Never expose sensitive keys in frontend

## Helpful Commands

```bash
# View Docker logs with timestamps
docker-compose logs --timestamps -f

# Rebuild only backend
docker-compose up --build autoplate-backend

# Remove all containers and volumes (WARNING: loses data)
docker-compose down -v

# Access backend container shell
docker-compose exec autoplate-backend sh

# Check container status
docker-compose ps

# Rebuild frontend without backend
docker-compose up --build autoplate-frontend
```

## Related Documentation
- See `README.md` for project overview
- See `INSTRUCTIONS.md` for detailed setup guide
- See `DEVELOPMENT.md` for development workflow

---

**Last Updated:** December 4, 2025
**Maintained By:** Development Team
